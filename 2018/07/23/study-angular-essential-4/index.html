<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords"><title>Angular essentials - typeScript - windfanta.github.io/blog</title><link rel="stylesheet" href="/blog/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/windfanta"><span>Github</span></a></li><li><a href="https://www.flickr.com/photos/69582358@N06/"><span>flickr</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">Angular essentials - typeScript</h1><ul class="meta"><li><i class="icon icon-author"></i>SUNGMIN SHIN</li><li><i class="icon icon-clock"></i>99 Minutes</li><li><i class="icon icon-calendar"></i>2018년 7월 23일</li></ul></div></div><div class="article-content" style="max-width:800px"><h1 id="Angular-essentials"><a href="#Angular-essentials" class="headerlink" title="Angular essentials"></a>Angular essentials</h1><p>(<a href="https://book.naver.com/bookdb/book_detail.nhn?bid=13761643" target="_blank" rel="noopener">https://book.naver.com/bookdb/book_detail.nhn?bid=13761643</a>)</p>
<p><br></p>
<h2 id="04-TypeScript"><a href="#04-TypeScript" class="headerlink" title="04. TypeScript"></a>04. TypeScript</h2><p><br></p>
<h3 id="4-1-TypeScript-개요"><a href="#4-1-TypeScript-개요" class="headerlink" title="4.1 TypeScript 개요"></a>4.1 TypeScript 개요</h3><p>HTML5가 등장하기 이전까지 웹 애플리케이션은 플래시, 실버라이트, 액티브엑스와 같은 플러그인에 의존하여 인터랙티브한 웹페이지를 구축해왔으나 HTML5가 등장함으로써 플러그 인에 의존하던 구축방식은 자바스크립트로 대체되었다.<br>또한 AJAX의 활성화로 데스크톱 애플리케이션과 유사한 사용자 경험을 제공할 수 있는 SPA(Single Page Application)가 대세가 되었고 과거 서버 측이 담당하던 업무의 많은 부분이 클라이언트 측으로 이동하게 되었고 자바스크립트는 웹의 어셈블리언어로 불릴만킄 중요한 언어로 그 위상이 높아지게 되었음</p>
<p>모든 프로그래밍 언어에 장, 단점이 있듯 자바스크립트도 언어가 잘 정제되기 이전에 서둘러 출시된 문제와 과거 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 만들어진 태생적 한계로 좋은 점도 나쁜 점도 많은 것이 사실이며 C나 java와 같은 C-Family 언어와는 구별되는 아래와 같은 특성이 있다.</p>
<ul>
<li>프로토타입 기반 객체지향 언어</li>
<li>스코프와 this</li>
<li>동적 타입(Dynamic Type) 언어(자세한 내용은 4.2 참고)</li>
</ul>
<p>이와 같은 특성은 코드가 복잡해질 수 있고 디버그와 테스트 공수가 증가하는 등의 문제를 일으 킬 수 있어 특히 규모가 큰 프로젝트에서 주의하여야 한다.<br>위와 같은 자바스크립트의 태생적 문제는 극복하기 위해 CoffeeScript, Dart, Haxe와 같은 AltJS(자바스크립트 대체언어)가 등장하였다.</p>
<p>TypeScript 또한 자바스크립트 대체 언어의 하나로 JavaScript(ES5)의 상위 집합(superset)으로 2012년 MS에서 발표, 정적 타이핑을 지원하며 ES6의 class, module과 ES7의 데코레이터 등을 지원한다.</p>
<p>TypeScript는 ES5의 상위 집합이므로 기존의 자바스크립트(ES5) 문법을 그대로 사용할 수 있으며 ES6의 새로운 기능을 사용하기 위해 바벨(babel)과 같은 별도의 트랜스파일러를 사용하지 않아도 ES6의 새로운 기능을 기존의 자바스크립트 엔진에서 실행할 수 있다. (TypeScript도 컴파일 과정을 거쳐야 하므로 실제 작업 과정 자체는 비슷하다고 볼 수 있음)</p>
<p>TypeScript는 이후 ECMAScript의 업그레이드에 따른 새로운 기능을 계속 추가할 예정이어서 매년 업그레이드 될 ECMAScript의 표준을 따라갈 수 있는 좋은 수단이 될 것</p>
<p><br></p>
<h3 id="4-2-TypeScript의-장점"><a href="#4-2-TypeScript의-장점" class="headerlink" title="4.2 TypeScript의 장점"></a>4.2 TypeScript의 장점</h3><h4 id="정적-타입"><a href="#정적-타입" class="headerlink" title="정적 타입"></a>정적 타입</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2개의 매개변수 a,b를 받아 더한 값을 반환하는 함수</span></span><br><span class="line"><span class="comment">	개발자는 의도는 매개변수로 number로 전달받는 것이였으나 코드 어디에도 표시되지 않으며 자바스크립트 문법상의 어떤 문제도 없음</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 사용하면 의도되지 않은 결과를 반환</span></span><br><span class="line">sum(<span class="string">'x'</span>, <span class="string">'y'</span>);</span><br></pre></td></tr></table></figure>
<p>위 코드는 개발자의 의도대로 실행되진 않지만 문법상에 어떠한 문제도 없으며 에러 없이 정상적으로 실행하게 된다.<br>이는 변수나 반환 값의 타입을 사전에 지정하지 않는 자바스크립트의 동적 타이핑(Dynamic Typing)에 의한 것</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typescript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수 및 반환 값의 type을 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 설정한 타입과 다른 값을 사용하면 컴파일 단계에서 오류 발생</span></span><br><span class="line">sum(<span class="string">'x'</span>, <span class="string">'y'</span>);</span><br></pre></td></tr></table></figure>
<p>위와 같이 TypeScript는 정적 타입(static type)을 지원하므로 컴파일 단계에서 오류를 포착할 수 있으며 명시적인 정적 타입의 지정으로 개발자의 의도를 명확하게 코드로 기술하여 코드의 가독성을 높일 뿐만아니라 디버깅을 쉽게할 수 있는 장점이 있다.</p>
<p><br></p>
<h4 id="강력한-객체지향-프로그래밍-지원"><a href="#강력한-객체지향-프로그래밍-지원" class="headerlink" title="강력한 객체지향 프로그래밍 지원"></a>강력한 객체지향 프로그래밍 지원</h4><p>인터페이스, 제네릭 등과 같은 강력한 객체지향 프로그래밍 지원은 크고 복잡한 프로젝트의 코드 기반을 쉽게 구성할 수 있도록 도우며 Java, C#등 클래스 기반 객체지향 언어에 익숙한 개발자가 자바스크립트 프로젝트를 수행하는 데 진입장 벽을 낮추는 효과도 있다.</p>
<p><br></p>
<h4 id="ES6-ESNext-지원"><a href="#ES6-ESNext-지원" class="headerlink" title="ES6 / ESNext 지원"></a>ES6 / ESNext 지원</h4><p>TypeScript는 별도의 개발환경을 구축해야 하므로 다소 복잡해진 측면이 있지만 ES6를 완전히 지원하지 않고 있는 브라우저들을 고려하여 Babel등의 트랜스파일러를 사용해야하는 현재의 상황임을 감안하면 TypeScript를 위한 환경 구축에 드는 수고는 크지 않음(트랜스파일러든, TypeScript 컴파일러든 어쨋든 한가지는 해야하는 상황이란 이야기)<br>또한 TypeScript는 ECMAScript 표준에 포함되지는 않았지만 표준화가 유력한 스펙을 선제적으로 도입하므로 유용한 기능을 안전하게 도입하기에 유리하다 (이건 babel도 마찬가지긴 함)</p>
<p><br></p>
<h3 id="4-3-TypeScript-개발환경-구축"><a href="#4-3-TypeScript-개발환경-구축" class="headerlink" title="4.3 TypeScript 개발환경 구축"></a>4.3 TypeScript 개발환경 구축</h3><p>TypeScript의 파일(.ts)은 브라우저에서 동작하지 않으므로 TypeScript 컴파일러를 이용해 자바스크립트 파일로 변환해야 한다.</p>
<p><br></p>
<h4 id="4-3-1-TypeScript-컴파일러-설치"><a href="#4-3-1-TypeScript-컴파일러-설치" class="headerlink" title="4.3.1 TypeScript 컴파일러 설치"></a>4.3.1 TypeScript 컴파일러 설치</h4><p>npm을 사용하여 TypeScript을 전역에 설치</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>버전확인</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-3-2-TypeScript-컴파일러-사용법"><a href="#4-3-2-TypeScript-컴파일러-사용법" class="headerlink" title="4.3.2 TypeScript 컴파일러 사용법"></a>4.3.2 TypeScript 컴파일러 사용법</h4><p>TypeScript 컴파일러(tsc)는 .ts파일을 .js파일로 컴파일(트랜스파일링) 한다.<br>(TypeScript 파일을 자바스크립트 파일로 변환하는 과정은 컴파일보다는 트랜스파일링이 더 적절한 표현이라고 함)</p>
<p><strong>person.ts의 파일의 변환(확장자는 생략해도 무방)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc person</span><br></pre></td></tr></table></figure></p>
<p><strong>person.ts / student.ts 복수의 파일 변환</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc person student</span><br></pre></td></tr></table></figure></p>
<p><strong>와일드 카드를 사용하여 모든 TypeScript의 파일 변환</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc *.ts</span><br></pre></td></tr></table></figure></p>
<p><strong>watch를 통한 자동변환(–watch / -w)</strong><br>(지정한 파일에 내용 변경이 일어나면 자동으로 감지하여 변환)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc person --watch</span><br></pre></td></tr></table></figure></p>
<p><strong>트랜스파일링될 js의 버전지정(–target/ - t)</strong><br>(별도의 선언 없이 트랜스파일링되는 .js파일의 버전은 ES3)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc person -t es6</span><br></pre></td></tr></table></figure></p>
<p>설정할 수 있는 버전은 ES3, ES5, ES6(ES2015), ES2016, ES2017(ESNext)이며 저 자세한 옵션들은 ‘typeScript Compiler Options’ 참고</p>
<blockquote>
<p>참고 - <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener">typeScript Compiler Options</a></p>
</blockquote>
<p><br></p>
<h3 id="4-4-정적-타이핑-static-typing"><a href="#4-4-정적-타이핑-static-typing" class="headerlink" title="4.4 정적 타이핑(static typing)"></a>4.4 정적 타이핑(static typing)</h3><h4 id="4-4-1-타입-선언"><a href="#4-4-1-타입-선언" class="headerlink" title="4.4.1 타입 선언"></a>4.4.1 타입 선언</h4><p>변수에서의 타입 선언은 변수명 뒤에 타입(자료형, data type)을 명시하는 것으로 타입을 선언할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo:<span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>
<p>함수에서의 타입은 아래와 같이 선언<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 매개변수(x, y)와 반환값에 대한 타입 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrow function</span></span><br><span class="line"><span class="keyword">const</span> multiply2 = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x * y;</span><br></pre></td></tr></table></figure></p>
<p>만약 선언한 타입에 맞지 않는 값을 할당하면 컴파일 시점에 에러가 발생하며 이는 변수, 함수 모두 동일<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar: <span class="built_in">number</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">multiply(<span class="string">'1'</span>, <span class="number">10</span>);</span><br><span class="line">multiply2(<span class="number">2</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>타입 선언은 개발자가 코드를 예측할 수 있도록 돕는 것과 동시에 문법이나 타입 에러 혹은 일치하지 않는 값의 할당등 기본 오류를 런타임 이전에 검출하며<br>IDE(EX&gt;vscode)에 따라 코드를 작성하는 시점에도 에러를 검출할 수 있는 등 개발효율을 크게 향상시켜 줄 수 있다.</p>
<p>아래와 같이 TypeScript는 자바스크립트의 superset으로 자바스크립트의 타입을 그대로 사용할 수 있을 뿐 아니라 typeScript 고유의 타입을 추가로 사용할 수 있음</p>
<p><strong>JavaScript와 TypeScript 함께 사용할 수 있는 데이터 타입</strong></p>
<table>
<thead>
<tr>
<th>타입(data type)</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>논리형 (true / false)</td>
</tr>
<tr>
<td>null</td>
<td>값이 없음을 명시</td>
</tr>
<tr>
<td>undefined</td>
<td>값을 할당하지 않은 변수의 초깃값</td>
</tr>
<tr>
<td>number</td>
<td>숫자(정수, 실수, Infinity, NaN)</td>
</tr>
<tr>
<td>string</td>
<td>문자열</td>
</tr>
<tr>
<td>symbol</td>
<td>고유하고 수정 불가능한 데이터 타입이며 주로 객체 프로퍼티의 식별자로 사용<br>(ES6에서 추가된 타입으로 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">MDN</a> 참고)</td>
</tr>
<tr>
<td>object</td>
<td>객체형</td>
</tr>
<tr>
<td>array</td>
<td>배열</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>TypeScript에서 사용할 수 있는 데이터 타입</strong></p>
<table>
<thead>
<tr>
<th>타입(data type)</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>tuple</td>
<td>고정된 요소 수만큼의 자료형을 미리 선언 후 배열을 표현</td>
</tr>
<tr>
<td>enum</td>
<td>열거형, 숫자 값 집합에 이름을 지정한 것</td>
</tr>
<tr>
<td>any</td>
<td>타입을 추론할 수 없거나 타입 체크가 필요없는 변수에 사용, var키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능</td>
</tr>
<tr>
<td>void</td>
<td>일반적으로 함수에서 반환값이 없을 때 사용</td>
</tr>
<tr>
<td>never</td>
<td>결코 발생하지 않는 값</td>
</tr>
</tbody>
</table>
<blockquote>
<p>참고 - <a href="https://infoscis.github.io/2017/05/14/TypeScript-handbook-basic-types/" target="_blank" rel="noopener">TypeScript 기본타입</a></p>
</blockquote>
<p><br></p>
<p><strong>TypeScript에서 타입 선언의 예</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span>: <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'Kim'</span>;</span><br><span class="line">name = <span class="string">'Lee'</span>;</span><br><span class="line"><span class="keyword">let</span> greeting: <span class="built_in">string</span> = <span class="string">`Hello my name is <span class="subst">$&#123;name&#125;</span>`</span>;		<span class="comment">// ES6 템플릿 문자열</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> list3: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];	<span class="comment">// 제네릭 배열 타입</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple - 고정된 요소의 수만큼 타입을 미리 선언 후 배열을 표현</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tuple = [<span class="string">'hello'</span>, <span class="number">20</span>];			<span class="comment">// ok!</span></span><br><span class="line">tuple = [<span class="number">10</span>, <span class="string">'hello'</span>];			<span class="comment">// error!</span></span><br><span class="line">tuple = [<span class="string">'hello'</span>, <span class="number">10</span>, <span class="literal">true</span>];	<span class="comment">// error!</span></span><br><span class="line">tuple.push(<span class="literal">true</span>);				<span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// enum - enum(열거형)은 숫자 값 집합에 이름을 지정한 것</span></span><br><span class="line"><span class="keyword">enum</span> Color1 &#123;Red, Green, Blue&#125;		<span class="comment">// 값을 지정하지 않으면 0부터 시작되어 순차적으로 증가(Red = 0, Green = 1, Blue = 2)</span></span><br><span class="line"><span class="keyword">let</span> c11: Color1 = Color1.Red;		<span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> c12: Color1 = Color1.Green;		<span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> c13: Color1 = Color1.Blue;		<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color2 &#123;Red = <span class="number">4</span>, Green, Blue&#125;	<span class="comment">// 값을 지정한 요소의 다음 요소들은 순차적으로 증가</span></span><br><span class="line"><span class="keyword">let</span> c21: Color2 = Color2.Red;		<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> c22: Color2 = Color2.Green;		<span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> c23: Color2 = Color2.Blue;		<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color3 &#123;Red, Green = <span class="number">4</span>, Blue&#125;	<span class="comment">// 초기 값이 지정되지 않은 첫번째 요소는 0</span></span><br><span class="line"><span class="keyword">let</span> c21: Color2 = Color2.Red;		<span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> c22: Color2 = Color2.Green;		<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> c23: Color2 = Color2.Blue;		<span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color4 &#123;Red = <span class="number">4</span>, Green = <span class="number">72</span>, Blue = <span class="number">999</span>&#125;	<span class="comment">// 요소의 값은 꼭 순차적이지 않아도 상관없음</span></span><br><span class="line"><span class="keyword">let</span> c21: Color2 = Color2.Red;					<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> c22: Color2 = Color2.Green;					<span class="comment">// 72</span></span><br><span class="line"><span class="keyword">let</span> c23: Color2 = Color2.Blue;					<span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// any - 타입 추론을 할 수 없거나 체크가 필요없는 변수에 사용</span></span><br><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">10</span>;</span><br><span class="line">notSure = <span class="string">'hello'</span>;		<span class="comment">// ok!</span></span><br><span class="line">notSure = <span class="literal">true</span>;			<span class="comment">// ok!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// void - 일반적으로 함수에서 반환 값이 없을 때 사용</span></span><br><span class="line"><span class="keyword">let</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">x:<span class="built_in">number</span></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">true<span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func2 = (x:<span class="built_in">number</span>):<span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">true<span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// never</span></span><br><span class="line"><span class="comment">// - 결코 발생하지 않는 값, 어떤 값도 할당할 수 없음</span></span><br><span class="line"><span class="comment">// - 함수에 사용하는 어떤 값도 리턴되지 않는 것을 넘어 도달 불가능한 부분(에러 호출이나 무한루프)이 있어야 타입체크를 통과</span></span><br><span class="line"><span class="keyword">let</span> neverVar: never = <span class="literal">null</span>;			<span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysError</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">true<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();				<span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">true<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">'inifinite'</span>);	<span class="comment">// ok!</span></span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>또한 TypeScript가 기본적으로 제공하는 타입은 모두 소문자로 대문자로 시작하는 타입의 표기는 타입의 래퍼객체 타입을 의미하므로 사용에 주의<br>(EX&gt; string(타입), String(래퍼객체타입))</p>
<p><br></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> primiteveStr: <span class="built_in">string</span>;</span><br><span class="line">primiteveStr = <span class="string">'hello'</span>;					<span class="comment">// ok!</span></span><br><span class="line">primiteveStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello!'</span>);	<span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectStr: <span class="built_in">String</span>;</span><br><span class="line">objectStr = <span class="string">'hello'</span>;					<span class="comment">// ok!</span></span><br><span class="line">objectStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>)			<span class="comment">// ok!</span></span><br></pre></td></tr></table></figure>
<p>위의 예시의 데이터 객체 외에 다른 객체의 유형도 타입이 될 수 있다.</p>
<p><br></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date 타입</span></span><br><span class="line"><span class="keyword">const</span> today: Data = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTMLElement 타입</span></span><br><span class="line"><span class="keyword">const</span> elem: HTMLElement = <span class="built_in">document</span>.getElementById(<span class="string">'myId'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용자 정의 타입(class)</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-4-2-정적-타이핑-static-typing"><a href="#4-4-2-정적-타이핑-static-typing" class="headerlink" title="4.4.2 정적 타이핑(static typing)"></a>4.4.2 정적 타이핑(static typing)</h4><p>정적 타이핑은 변수를 선언할 때 변수에 할당할 값의 타입에 따라 사전에 타입을 명시적으로 선언해야하며 선언한 타입에 맞는 값을 할당해야 함.</p>
<p>자바스크립트는 동적 타입(dynamic type)언어 혹은 느슨한 타입(loosely typed)언어로 변수 타입 선언 없이 값이 할당되는 과정에서 동적으로 타입을 추론하며 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있음 이러한 동적 타이핑은 사용하기 간편하지만 코드를 예측하기 힘들어 예상치 못한 오류를 만들 가능성이 높음</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript(dynamic type)</span></span><br><span class="line"><span class="keyword">let</span> foo;		<span class="comment">// undefined</span></span><br><span class="line">foo = <span class="literal">null</span>;		<span class="comment">// null</span></span><br><span class="line">foo = &#123;&#125;;		<span class="comment">// object</span></span><br><span class="line">foo = <span class="number">3</span>;		<span class="comment">// number</span></span><br><span class="line">foo = <span class="number">3.14</span>;		<span class="comment">// number</span></span><br><span class="line">foo = <span class="string">'hello'</span>;	<span class="comment">// string</span></span><br><span class="line">foo = <span class="literal">true</span>;		<span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>
<p>정적 타이핑은 TypeScript의 가장 독특한 특징으로 타입을 명시적으로 선언하며 타입이 결정된 후에는 타입을 변경할 수 없다. 잘못된 타입의 값이 할당, 반환되면 컴파일러는 이를 감지하여 에러를 발생시킨다.</p>
<p><br></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript(static type)</span></span><br><span class="line"><span class="keyword">let</span> foo: <span class="built_in">string</span>,</span><br><span class="line">truebar: <span class="built_in">number</span>,</span><br><span class="line">truebaz: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">foo = <span class="string">'hello'</span>;	<span class="comment">// ok!</span></span><br><span class="line">bar = <span class="number">123</span>;		<span class="comment">// ok!</span></span><br><span class="line">baz = <span class="string">'true'</span>	<span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수에서의 사용</span></span><br><span class="line"><span class="keyword">let</span> add = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>);	<span class="comment">// 30</span></span><br><span class="line">add(<span class="string">'10'</span>, <span class="number">20</span>)	<span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>정적, 동적 타이핑의 우위에 대한 것은 절대적으로 평가할 수 없지만 정적 타이핑의 장점인 코드 가독성, 예측성, 안정성은 대규모 프로젝트에 매우 적합하다.</p>
<p><br></p>
<h4 id="4-4-3-타입-추론-type-inference"><a href="#4-4-3-타입-추론-type-inference" class="headerlink" title="4.4.3 타입 추론(type inference)"></a>4.4.3 타입 추론(type inference)</h4><p>TypeScript에서도 타입 선언을 생략하면 값이 할당되는 과정에서 any로 설정되어 동적으로 타입이 결정된다. 하지만 이러한 방식은 TypeScript의 장점을 없애기 때문에 사용하지 않는 것을 권장<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line">foo = <span class="string">'hello'</span>;	<span class="comment">// string</span></span><br><span class="line">foo = <span class="literal">true</span>		<span class="comment">// boolean</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="4-5-클래스"><a href="#4-5-클래스" class="headerlink" title="4.5 클래스"></a>4.5 클래스</h3><p>ES6에서 도입된 클래스는 클래스 기반의 언어에 익숙한 개발자가 보다 빠르게 학습할 수 있는 단순명료한 새로운 문법을 제시하고 있다.<br>(클래스는 사실 새로운 모델을 제공하는 것은 아니고 클래스도 함수로 기존의 프로토타입 기반 패턴의 문법적 설탕이다)<br>TypeScript에서의 클래스는 ES6의 클래스와 상당히 유사하지만 몇 가지 고유한 확장기능을 가지고 있다.</p>
<p><br></p>
<h4 id="4-5-1-클래스-정의"><a href="#4-5-1-클래스-정의" class="headerlink" title="4.5.1 클래스 정의"></a>4.5.1 클래스 정의</h4><p>ES6의 클래스는 아래와 같이 클래스 몸체에 프로퍼티를 선언할 수 없고 반드시 생성자(constructor) 내부에서 클래스 프로퍼티를 선언하고 초기화 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javaScript</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">true<span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.name = name;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truewalk() &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is walking`</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 ES6에서는 문제없이 실행되지만 TypeScript에서는 컴파일에러가 발생한다.</p>
<p><br></p>
<p><strong>TypeScript에서는 클래스 몸체에 클래스 프로퍼티를 사전에 선언해야 한다.</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeScript</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">truename: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.name = name;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truewalk() &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> is walking`</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>);</span><br><span class="line">person.walk();						<span class="comment">// 'Lee is walking'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-5-2-접근제한자"><a href="#4-5-2-접근제한자" class="headerlink" title="4.5.2 접근제한자"></a>4.5.2 접근제한자</h4><p>es6의 class와 달리 클래스 기반의 다른 언어처럼 TypeScript의 class에서는 접근제한자를 지원한다.</p>
<blockquote>
<p><strong>TypeScript의 class에서 지원하는 접근제한자</strong></p>
<ul>
<li>public(접근제한자를 생략하면 public으로 선언)</li>
<li>protected</li>
<li>private</li>
</ul>
</blockquote>
<p><strong>접근제한자를 선언한 프로퍼티와 메서드의 접근 가능성</strong></p>
<table>
<thead>
<tr>
<th>접근 가능성</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>클래스 내부</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>자식 클래스 내부</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>클래스 인스턴스</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">true<span class="keyword">public</span> x: <span class="built_in">string</span>;	<span class="comment">// public은 생략해도 무방</span></span><br><span class="line">true<span class="keyword">protected</span> y: <span class="built_in">string</span>;</span><br><span class="line">true<span class="keyword">private</span> z: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span>, z: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.x = x;</span><br><span class="line">truetrue<span class="keyword">this</span>.y = y;</span><br><span class="line">truetrue<span class="keyword">this</span>.z = z;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);		<span class="comment">// ok!</span></span><br><span class="line"><span class="built_in">console</span>.log(y);		<span class="comment">// error!</span></span><br><span class="line"><span class="built_in">console</span>.log(z);		<span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar</span></span><br><span class="line"><span class="keyword">class</span> Bar <span class="keyword">extends</span> Foo &#123;</span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span>, z: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">truetrue<span class="keyword">super</span>(x, y, z);</span><br><span class="line"></span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="keyword">this</span>.x);	<span class="comment">// ok!(public)</span></span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="keyword">this</span>.y);	<span class="comment">// ok!(protected)</span></span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="keyword">this</span>.z);	<span class="comment">// error!(private)</span></span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-5-2-생성자-파라미터에-접근제한자-선언"><a href="#4-5-2-생성자-파라미터에-접근제한자-선언" class="headerlink" title="4.5.2 생성자 파라미터에 접근제한자 선언"></a>4.5.2 생성자 파라미터에 접근제한자 선언</h4><p>접근 제한자는 생성자 파라미터에도 선언할 수 있다. <strong>이때 접근 제한자가 사용된 생성자 파라미터는 암묵적으로 클래스 프로퍼티로 선언되고 생성자 내부에서 별도의 초기화가 없어도 암묵적으로 초기화가 수행된다.</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> x: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'hello~!'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.x);	<span class="comment">// ok!('hello')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar &#123;</span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> x: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> Bar(<span class="string">'hi~!'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(bar);</span><br><span class="line"><span class="built_in">console</span>.log(bar.x);	<span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p><strong>생성자 내부에 별도의 접근 제한자를 선언하지 않으면 생성자 파라미터는 생성자 내부에서만 유효한 지역변수가 되어 외부 참조가 불가능해진다.</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'hello~!'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(foo);	<span class="comment">// x프로퍼티가 존재하지 않음</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-5-3-readonly-키워드"><a href="#4-5-3-readonly-키워드" class="headerlink" title="4.5.3 readonly 키워드"></a>4.5.3 readonly 키워드</h4><p>TypeScript는 readonly 키워드를 사용할 수 있는데 <strong>readonly가 선언된 클래스 프로퍼티는 선언 시 또는 생성자 내부에서만 값을 할당할 수 있게 된다.</strong><br>그 외에 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 되며 이를 이용하여 상수의 선언에 사용한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">true<span class="comment">// readonly로 클래스 프로퍼티 생성</span></span><br><span class="line">true<span class="keyword">private</span> readonly MSG: <span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">truetrue<span class="comment">// 생성자 내부에서는 readonly 프로퍼티도 할당가능</span></span><br><span class="line">truetrue<span class="keyword">this</span>.MSG = <span class="string">'ho'</span>;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truelog() &#123;</span><br><span class="line">truetrue<span class="comment">// 생성자와 선언 시점이 아닌 곳에서 값을 할당하는 경우 컴파일 시점에서 에러</span></span><br><span class="line">truetrue<span class="comment">//this.MSG = 'hi!';</span></span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="keyword">this</span>.MSG);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.log();</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-5-5-static-키워드"><a href="#4-5-5-static-키워드" class="headerlink" title="4.5.5 static 키워드"></a>4.5.5 static 키워드</h4><p>ES6에서의 static 키워드는 정적 메서드를 정의하는데 사용된다.<br>정적 메서드는 클래스의 인스턴스가 아닌 클래스 이름으로 호출하며 그렇기 때문에 인스턴스를 생성하지 않아도 호출할 수 있음</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">true<span class="keyword">constructor</span>(prop) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.prop = prop;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">static</span> staticMethod() &#123;</span><br><span class="line">truetrue<span class="comment">// static 키워드로 정의한 정적 메서드에서는 this를 사용할 수 없음</span></span><br><span class="line">truetrue<span class="comment">// 정적 메서드 내부에서의 this는 클래스의 인스턴스가 아닌 자신을 가리킴</span></span><br><span class="line">truetrue<span class="keyword">return</span> <span class="string">'static method'</span>;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueprototypeMethod() &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.staticMethod());	<span class="comment">// 'static method'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.staticMethod())		<span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>TypeScript에서는 static 키워드를 클래스 프로퍼티에도 사용할 수 있다.</strong> 정적 클래스 프로퍼티는 정적 메서드와 마찬가지로 인스턴스가 아닌 클래스 이름으로 호출하며 클래스의 인스턴스를 생성하지 않아도 호출할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">true<span class="comment">// 생성된 인스턴스의 개수</span></span><br><span class="line">true<span class="keyword">static</span> instanceCounter: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">truetrue<span class="comment">// 인스턴스가 생성될 때마다 1씩 증가</span></span><br><span class="line">truetrue<span class="keyword">this</span>.instanceCounter++;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceCounter을 증가시키기 위해 인스턴스 생성</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> foo2 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.instanceCounter);	<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.instanceCounter);	<span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-5-6-추상-클래스-abstract"><a href="#4-5-6-추상-클래스-abstract" class="headerlink" title="4.5.6 추상 클래스(abstract)"></a>4.5.6 추상 클래스(abstract)</h4><p>추상 클래스(abstract class)는 abstract 키워드를 사용하며 선언하며 하나 이상의 추상 메서드를 포함한다. 직접 인스턴스를 생성할 수 없고 상속만을 위해 사용된다.<br>추상 클래스를 상속한 클래스는 추상 클래스의 추상 메서드를 반드시 구현해야한다.<br>4.5.7의 인터페이스(interface)는 추상 클래스와 유사하지만 모든 메서드가 추상 메서드라는 차이가 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 추상 클래스</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">true<span class="comment">// 추상 메서드</span></span><br><span class="line">true<span class="comment">// 메서드는 프로퍼티와 달리 ()를 표기</span></span><br><span class="line">true<span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">truemove(): <span class="built_in">void</span> &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">'roaming the earth'</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">true<span class="comment">// Animal을 상속 받았으므로 추상 메서드인 makeSound는 반드시 구현해야 함</span></span><br><span class="line">truemakeSound() &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">'bowwow~'</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const animal = new Animal();	// error!(추상 클래스는 인스턴스를 직접 생성할 수 없음)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> Dog();</span><br><span class="line">myDog.makeSound();				<span class="comment">// 'bowwow~'</span></span><br><span class="line">myDog.move();					<span class="comment">// 'roaming the earth'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="4-6-인터페이스-interface"><a href="#4-6-인터페이스-interface" class="headerlink" title="4.6 인터페이스(interface)"></a>4.6 인터페이스(interface)</h3><p>인터페이스는 <strong>일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용</strong>할 수 있다.<br>인터페이스는 여러 가지 자료형을 갖는 프로퍼티로 이루어진 새로운 자료형을 정의하는 것과 유사한데 인터페이스에 선언된 프로퍼티 또는 메소드의 구현을 강제하여 일관성을 유지할 수 있도록 하는 것<br>인터페이스는 프로퍼티와 메서드를 가질 수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성할 수 없고 모든 메서드가 추상 메서드이다.(가상 클래스는 일반 메서드도 생성할 수 있음) 그리고 추상 메서드와 달리 abstract 키워드를 사용하지 않는다.</p>
<p><br></p>
<h4 id="4-6-1-변수와-인터페이스"><a href="#4-6-1-변수와-인터페이스" class="headerlink" title="4.6.1 변수와 인터페이스"></a>4.6.1 변수와 인터페이스</h4><p>인터페이스는 변수의 타입으로 사용할 수 있는데 이때 인터페이스를 타입으로 선언한 변수는 해당 인터페이스를 준수해야 한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">trueid: <span class="built_in">number</span>;</span><br><span class="line">truecontent: <span class="built_in">string</span>,</span><br><span class="line">truecompleted: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 todo의 type을 interface인 Todo로 설정</span></span><br><span class="line"><span class="keyword">let</span> todo:Todo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 값은 설정한 인터페이스를 준수해야함</span></span><br><span class="line">todo = &#123;</span><br><span class="line">trueid: <span class="number">1</span>,</span><br><span class="line">truecontent: <span class="string">'typeScript'</span>,</span><br><span class="line">truecompleted: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>인터페이스를 사용하여 함수 파라미터의 타입도 선언할 수 있는 데 당연히도 해당 함수는 함수 파라미터의 타입으로 지정한 인터페이스를 준수하는 인수를 전달해야 한다.<br>함수의 객체를 전달할 때 복잡한 매개변수 체크가 필요 없어서 유용하다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">trueid: <span class="built_in">number</span>;</span><br><span class="line">truecomtent: <span class="built_in">string</span>;</span><br><span class="line">truecompleted: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todos: Todo[] = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 addTodo의 파라미터 type을 Todo로 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">todo: Todo</span>) </span>&#123;</span><br><span class="line">true<span class="comment">// ...은 rest parameter</span></span><br><span class="line">truetodos = [...todos, todo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newTodo: Todo = &#123;</span><br><span class="line">trueid: <span class="number">1</span>,</span><br><span class="line">truecontent: <span class="string">'typeScript'</span>,</span><br><span class="line">truecompleted: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addTodo(newTodo);</span><br><span class="line"><span class="built_in">console</span>.log(todos);	<span class="comment">// &#123; id: 1, content: 'typeScript', completed: false &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>참고 - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener">rest parameter</a></p>
</blockquote>
<p><br></p>
<h4 id="4-6-2-함수와-인터페이스"><a href="#4-6-2-함수와-인터페이스" class="headerlink" title="4.6.2 함수와 인터페이스"></a>4.6.2 함수와 인터페이스</h4><p>인터페이스는 함수의 타입으로도 사용할 수 있다. 이때 함수의 인터페이스에는 타입이 선언된 파라미터와 리턴 타입을 정의한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인터페이스 SquareFunc은 함수의 타입</span></span><br><span class="line"><span class="keyword">interface</span> SquareFunc &#123;</span><br><span class="line">true<span class="comment">// 파라미터 및 반환값의 type정의</span></span><br><span class="line">true(num: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squereFunc: SquereFunc = <span class="function"><span class="keyword">function</span>(<span class="params">num: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squereFunc(<span class="number">10</span>));	<span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-6-3-클래스와-인터페이스"><a href="#4-6-3-클래스와-인터페이스" class="headerlink" title="4.6.3 클래스와 인터페이스"></a>4.6.3 클래스와 인터페이스</h4><p><strong>클래스 선언문의 implements뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현하여야 한다.</strong> 이는 인터페이스를 구현하는 클래스의 일관성을 유지할 수 있다는 장점을 갖는다.<br>(인터페이스는 프로퍼티와 메소드를 가질 수 있다는 점에서 클래스와 유사하나 직접 인터페이스를 생성할 수는 없다.)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인터페이스 ITodo 정의</span></span><br><span class="line"><span class="keyword">interface</span> ITodo &#123;</span><br><span class="line">trueid: <span class="built_in">number</span>;</span><br><span class="line">truecontent: <span class="built_in">string</span>;</span><br><span class="line">truecompleted: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Todo <span class="keyword">implements</span> ITodo &#123;</span><br><span class="line">true<span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">		<span class="keyword">public</span> id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">		<span class="keyword">public</span> content: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">		<span class="keyword">public</span> completed: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">	</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo = <span class="keyword">new</span> Todo(<span class="number">1</span>, <span class="string">'typeScript'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(todo); 	<span class="comment">// &#123; id: 1, content: 'typeScript', completed: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>인터페이스는 프로퍼티 뿐만 아니라 메소드도 포함할 수 있다.<br>(단 모든 메소드는 추상메소드이어야 하며 프로퍼티와 마찬가지로 인터페이스에서 정의한 추상 메소드는 반드시 구현하여야 한다.)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">truename: <span class="built_in">string</span>;</span><br><span class="line">truesayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Iperson &#123;</span><br><span class="line">true<span class="keyword">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">		<span class="keyword">public</span> name: <span class="built_in">string</span></span></span><br><span class="line"><span class="params">	</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">truesayHello() &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">`Hi~ <span class="subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: IPerson</span>) </span>&#123;</span><br><span class="line">trueperson.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line"></span><br><span class="line">greeter(me);		<span class="comment">// 'Hi~ kim'</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-6-4-덕-타이핑-duck-typing"><a href="#4-6-4-덕-타이핑-duck-typing" class="headerlink" title="4.6.4 덕 타이핑(duck typing)"></a>4.6.4 덕 타이핑(duck typing)</h4><p>주의해야 할 것은 인터페이스를 구현하였다는 것만이 타입 체크를 통과하는 유일한 방법은 아니다. 타입 체크에서 중요한 것은 값을 실제로 가지고 있다는 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 인터페이스 IDuck을 정의</span></span><br><span class="line"><span class="keyword">interface</span> IDuck &#123;</span><br><span class="line">truequack():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 클래스 MallardDuck은 인터페이스 IDuck을 구현</span></span><br><span class="line"><span class="keyword">class</span> MallardDuck <span class="keyword">implements</span> IDuck &#123;</span><br><span class="line">truequack() &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">'Quack!'</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 클래스 RedheadDuck은 인터페이스 IDuck을 구현하지는 않았지만 인터페이스 IDuck과 동일한 구조를 가짐</span></span><br><span class="line"><span class="keyword">class</span> RedheadDuck &#123;</span><br><span class="line">truequack() &#123;</span><br><span class="line">truetrue<span class="built_in">console</span>.log(<span class="string">'Q~uack!'</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 함수 makeNoise는 매개변수로 duck(IDuck의 인터페이스를 구현한)을 전달받음</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoise</span>(<span class="params">duck: IDuck</span>) </span>&#123;</span><br><span class="line">trueduck.quack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">makeNoise(<span class="keyword">new</span> MallardDuck());	<span class="comment">// 'Quack!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. IDuck 인터페이스를 구현하지 않는 매개변수를 사용해도 이상없이 동작</span></span><br><span class="line">makeNoise(<span class="keyword">new</span> RedheadDuck());	<span class="comment">// 'Q~uack!'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>인터페이스 IDuck은 quack 메서드를 정의</li>
<li>함수 makeNoise는 매개변수로 duck(IDuck의 인터페이스를 구현한)을 전달받음</li>
<li>클래스 MallardDuck은 인터페이스 IDuck을 구현</li>
<li>클래스 RedheadDuck은 인터페이스 IDuck을 구현하지는 않았지만 인터페이스 IDuck과 동일한 구조를 가짐</li>
<li>IDuck 인터페이스를 구현하지 않는 매개변수를 사용해도 이상없이 동작</li>
</ol>
</blockquote>
<p><strong><strong>TypeScript는 해당 인터페이스에서 정의한 프로퍼티나 메서드를 가지고 있다면 그 인터페이스를 구현한 것으로 인정한다.</strong></strong><br>이 것을 덕 타이핑(duck typing) 또는 구조적 타이핑이라고 한다. 인터페이스를 변수에 사용할 경우에도 덕 타이핑은 적용된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">truename:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: IPerson</span>) </span>&#123;</span><br><span class="line">true<span class="built_in">console</span>.log(<span class="string">`hello~ <span class="subst">$&#123;person.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인터페이스 IPerson을 구현하지 않았음</span></span><br><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">truename: <span class="string">'Lee'</span>,</span><br><span class="line">trueage: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHello(me); <span class="comment">// 'hello~ Lee'</span></span><br></pre></td></tr></table></figure>
<p><strong>인터페이스는 개발 단계에서 도움을 주기 위해 제공되는 기능으로 자바스크립트의 표준이 아니다.</strong> 위 예제의 TypeScript 파일을 자바스크립트 파일로 트랜스파일링하면 아래와 같이 인터페이스가 삭제된다.</p>
<p><br></p>
<h4 id="4-6-5-선택적-프로퍼티-optional-property"><a href="#4-6-5-선택적-프로퍼티-optional-property" class="headerlink" title="4.6.5 선택적 프로퍼티(optional property)"></a>4.6.5 선택적 프로퍼티(optional property)</h4><p>인터페이스 프로퍼티는 반드시 구현되어야 한다. 하지만 인터페이스의 프로퍼티가 선택적으로 필요한 경우가 있을 수 있는데 이때 선택적 프로퍼티로 선언할 수 있다.<br>선택적 프로퍼티는 프로퍼티명 뒤에 ‘?’를 붙여 사용하며 생략하여도 에러가 발생하지 않는다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인터페이스 UserInfo의 age, address 프로퍼티는 생략 가능하다.</span></span><br><span class="line"><span class="keyword">interface</span> UserInfo &#123;</span><br><span class="line">trueuserName: <span class="built_in">string</span>;</span><br><span class="line">truepassWord: <span class="built_in">string</span>;</span><br><span class="line">trueage?	: <span class="built_in">number</span>;</span><br><span class="line">trueaddress?: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo: UserInfo = &#123;</span><br><span class="line">trueuserName: <span class="string">'aaa@asd.com'</span>,</span><br><span class="line">truepassword: <span class="string">'q1w2e3'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(userInfo);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-6-7-제네릭"><a href="#4-6-7-제네릭" class="headerlink" title="4.6.7 제네릭"></a>4.6.7 제네릭</h4><p>정적 타입 언어는 함수 또는 클래스를 정의하는 시점에 매개변수나 반환 값의 타입을 선언하여야 한다. 하지만 함수 또는 클래스를 정의하는 시점에 매개변수, 반환 값의 타입을 지정하기 어려운 경우가 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue &#123;</span><br><span class="line">true<span class="keyword">protected</span> data = [];</span><br><span class="line"></span><br><span class="line">truepush(item) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.data.push(item);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truepop() &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'1'</span>);	<span class="comment">// 의도하지 않은 실수(data에 들어가는 모든 값은 숫자일 것으로 예상)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// error! (toFixed는 Number의 메서드이므로)</span></span><br></pre></td></tr></table></figure>
<p>위 예제는 FIFO(First In First Out)구조로 데이터를 저장하는 큐를 표현한 것으로 data 프로퍼티에 타입 선언을 생략하여 any[] 타입으로 설정되었으며 any[] 타입은 어떤 타입의 요소도 가질 수 있다는 것을 의미한다.<br>즉 저장하는 값은 어떤 타입의 값이던 포함할 수 있게되므로 숫자만 들어올 것이라는 기대를 충족하지 못하게 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue &#123;</span><br><span class="line">true<span class="keyword">protected</span> data = [];</span><br><span class="line"></span><br><span class="line">truepush(item) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.data.push(item);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truepop() &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> NumberQueue <span class="keyword">extends</span> Queue &#123;</span><br><span class="line">truepush(item: <span class="built_in">number</span>) &#123;</span><br><span class="line">truetrue<span class="keyword">super</span>.push(item);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truepop() &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> NumberQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// queue.push('1');	// 컴파일 과정에서 에러 발생</span></span><br><span class="line">queue.push(+<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>이러한 문제를 해결하기 위해 Queue를 상속 받는 number타입 전용의 클래스를 정의하였다. 하지만 다양한 타입을 지원해야 한다면 타입 별로 클래스를 상속 받아 추가해야하므로 이 또한 좋은 방법은 아니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue&lt;T&gt; &#123;</span><br><span class="line">true<span class="keyword">protected</span> data: <span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line"></span><br><span class="line">truepush(item: T) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.data.push(item);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truepop() &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 전용 Queue</span></span><br><span class="line"><span class="keyword">const</span> numberQueue = <span class="keyword">new</span> Queue&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">numberQueue.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// queue.push('1');	// 컴파일 과정에서 에러 발생</span></span><br><span class="line">queue.push(+<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 전용 Queue</span></span><br><span class="line"><span class="keyword">const</span> stringQueue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">stringQueue.push(<span class="string">'hello'</span>);</span><br><span class="line">stringQueue.push(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())	<span class="comment">// 'world'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 커스텀 객체 전용 Queue</span></span><br><span class="line"><span class="keyword">const</span> myQueue = <span class="keyword">new</span> Queue&lt;&#123;</span><br><span class="line">truename: <span class="built_in">string</span>,</span><br><span class="line">trueage: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;;</span><br><span class="line"></span><br><span class="line">myQueue.push(&#123;</span><br><span class="line">truename: <span class="string">'Lee'</span>,</span><br><span class="line">trueage: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line">myQueue.push(&#123;</span><br><span class="line">truename: <span class="string">'kim'</span>,</span><br><span class="line">trueage: <span class="number">40</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myQueue.pop());		<span class="comment">// &#123;name: 'Lee', age: 20&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myQueue.pop());		<span class="comment">// &#123;name: 'kim', age: 40&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>제네릭은 선언 시점이 아닌 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다.</strong> 한번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다.<br><strong>T</strong>는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 ‘타입 파라미터(type parameter)라 한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> item.reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arg = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수에 따라 타입 매개변수가 결정</span></span><br><span class="line"><span class="keyword">const</span> reserved = reverse(arg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reversed);		<span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 함수에서도 제네릭을 사용할 수 있는 데 reverse 함수는 인수의 타입에 의해 매개변수가 결정된다.<br>예를 들어 위와 같이 number타입의 요소를 갖는 배열을 전달받으면 타입 매개변수가 number가 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> item.reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arg = [</span><br><span class="line">true&#123;name: <span class="string">'Lee'</span>&#125;,</span><br><span class="line">true&#123;name: <span class="string">'kim'</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> revesed = reverse(arg);</span><br><span class="line"><span class="built_in">console</span>.log(reversed);			<span class="comment">// [ &#123;name: 'kim'&#125;, &#123;name: 'Lee'&#125; ]</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 name의 타입이 string을 갖는 요소의 배열을 전달 받으면 타입 매개변수는 <strong>{ name: string }</strong> 이 된다.</p>
<blockquote>
<p>참고</p>
<ul>
<li><a href="https://jaeyeophan.github.io/2017/12/30/TS-5-Generics-in-TypeScript/" target="_blank" rel="noopener">Generics in TypeScript</a></li>
<li><a href="https://zetawiki.com/wiki/%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%99%80_%EC%9D%B8%EC%88%98%EC%9D%98_%EC%B0%A8%EC%9D%B4" target="_blank" rel="noopener">인수와 매개변수</a></li>
</ul>
</blockquote>
</div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/study/">study</a><span class="category-list-count">37</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/study/angular/">angular</a><span class="category-list-count">3</span></li></ul></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/blog/2018/07/25/study-angular-essential-6/"><i class="icon icon-arror-left"></i></a></li><li><a href="/blog/2018/04/03/study-jquery-12/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/windfanta" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.flickr.com/photos/69582358@N06/" title="flickr" target="_blank"><i class="icon icon-flickr"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 windfanta.github.io/blog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>