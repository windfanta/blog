<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords"><title>(ES6) - 02 let, const - windfanta.github.io/blog</title><link rel="stylesheet" href="./css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/windfanta"><span>Github</span></a></li><li><a href="https://www.flickr.com/photos/69582358@N06/"><span>flickr</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">(ES6) - 02 let, const</h1><ul class="meta"><li><i class="icon icon-author"></i>SUNGMIN SHIN</li><li><i class="icon icon-clock"></i>29 Minutes</li><li><i class="icon icon-calendar"></i>2017년 9월 13일</li></ul></div></div><div class="article-content" style="max-width:800px"><h1 id="ECMA-Script6"><a href="#ECMA-Script6" class="headerlink" title="[ ECMA Script6 ]"></a>[ ECMA Script6 ]</h1><p>(<a href="http://book.naver.com/bookdb/book_detail.nhn?bid=11556385" target="_blank" rel="noopener">http://book.naver.com/bookdb/book_detail.nhn?bid=11556385</a>)</p>
<p><br></p>
<h1 id="2-1-var-키워드"><a href="#2-1-var-키워드" class="headerlink" title="2.1 var 키워드"></a>2.1 var 키워드</h1><hr>
<p>변수는 크게 로컬(지역)변수와 글로벌(전역)변수로 구분하는데 이는 스코프 때문으로 지역 변수는 함수 또는 오브젝트를 스코프로 사용하려는 의도이며 전역 변수는 프로그램 전체에서 공용으로 사용하려는 목적 입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-1] */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var 키워드를 생략하여 글로벌 변수로 one을 선언</span></span><br><span class="line">one = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 함수 내부에 존재하지만 var 키워드를 생략하여 글로벌 변수의 값을 변경</span></span><br><span class="line">  one = <span class="number">300</span>;</span><br><span class="line">  <span class="comment">// 로컬 변수 one이 존재하지 않기 때문에 글로벌 변수 one을 참조</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'함수:'</span>, one);</span><br><span class="line">&#125;</span><br><span class="line">get();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'글로벌'</span>, one);</span><br></pre></td></tr></table></figure>
<p>이 예제에서 변수 one은 클로저로 사용하기 위한 의도적인 접근일 수 있지만 다른 프로그램에서 같은 이름의 변수를 사용하는 경우 의도하지 않는 값이 설정될 수 있습니다.<br><br></p>
<h3 id="글로벌-변수의-오해"><a href="#글로벌-변수의-오해" class="headerlink" title="글로벌 변수의 오해"></a>글로벌 변수의 오해</h3><p>글로벌 오브젝트에 작성한 변수는 글로벌 오브젝트가 스코프 입니다. 즉 글로벌 오브젝트에 작성 했으므로 글로벌 변수라고 부르는 것이지 글로벌 오브젝트에서 보면 로컬 변수 입니다.<br>var 키워드를 사용하지 않으면 글로벌 변수로 간주된다는 점으로 인해 작성하지 않고 사용하기도 하지만 글로벌 변수가 var 키워드를 사용하지 않는 것은 아닙니다.</p>
<p>글로벌 변수가 편리할 수 있지만 객체지향의 관점에서는 단점이 됩니다.<br>이는 마치 내가 사는 집(글로벌 오브젝트)의 물건(글로벌 변수)을 아무나 사용하는 모습으로 다른 사람이 내 물건을 사용하려면 나에게 허락을 받거나 내가 다른 사람들이 사용할 수 있도록 조치를 취해야 합니다.<br>함수 안에서 글로벌 오브젝트에 작성된 글로벌 변수를 사용할 수 있지만 다른 프로그램에서 값을 변경할 수도 있다는 위험은 감수해야 합니다.<br><br></p>
<h3 id="use-strict의-사용"><a href="#use-strict의-사용" class="headerlink" title="use strict의 사용"></a>use strict의 사용</h3><p>use strict는 ES5의 새로운 기능으로 일종의 엄격 모드입니다.<br>프로그램을 엄격한 운용 컨텍스트 안에서 실행시킬 수 있게 끔 해주고 정의되지 않은 변수를 사용하거나 변수나 객체를 삭제하는 경우, 함수 매개변수에 중복된 이름 등 올바르지 않은 문법들에 대해 좀 더 많은 예외를 발생 시킵니다.<br>사용 영역은 글로벌, 함수(지역)으로 나누어 사용할 수 있으며 사용 시 최상위에 선언되어야 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역에서 선언</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 지역(함수)에서 선언</span></span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>(참고 - <a href="http://hmmim.tistory.com/5" target="_blank" rel="noopener">http://hmmim.tistory.com/5</a>)</p>
</blockquote>
<p><br></p>
<h1 id="2-2-let-키워드"><a href="#2-2-let-키워드" class="headerlink" title="2.2 let 키워드"></a>2.2 let 키워드</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>;</span><br></pre></td></tr></table></figure>
<p>위 형태가 let 키워드로 변수를 선언한 것 입니다.<br>var 키워드의 문제점을 해결하기 위한 것으로 아래와 같은 특징이 있습니다.</p>
<blockquote>
<ol>
<li>함수 안에 작성한 let 변수는 함수가 스코프(함수에 중괄호가 존재하므로 기존과 동일)</li>
<li>함수 안에 if등 블록(중괄호) 내에 선언했다면 중괄호가 스코프</li>
<li>블록 밖에 값은 이름의 변수가 있어도 스코프가 다르므로 각각의 변수에 값을 선언할 수 있으며 값이 유지됩니다</li>
<li>블록 안에 블록을 계층적으로 작성하면 각각의 블록이 스코프가 됩니다</li>
<li>같은 스코프에서 같은 이름의 let 변수를 선언할 수 없습니다(에러 발생)</li>
<li>let 변수는 호이스팅이 되지 않습니다.</li>
</ol>
</blockquote>
<p><br></p>
<h1 id="2-3-let-변수-작성-방법"><a href="#2-3-let-변수-작성-방법" class="headerlink" title="2.3 let 변수 작성 방법"></a>2.3 let 변수 작성 방법</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">// 초기 값 없이 선언 가능</span></span><br><span class="line"><span class="keyword">let</span> book;</span><br><span class="line"><span class="comment">// 초기 값을 포함한 선언</span></span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>;</span><br><span class="line"><span class="comment">// 선언된 값의 변경</span></span><br><span class="line">sports = <span class="string">'농구'</span>;</span><br><span class="line"><span class="comment">// var 키워드처럼 컴마로 구분하여 연속으로 생성 가능</span></span><br><span class="line"><span class="keyword">let</span> one = <span class="number">1</span>, two = <span class="number">2</span>, three;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// let 키워드를 사용하여 동일한 이름의 변수는 생성 불가</span></span><br><span class="line"><span class="comment">let sports = '배구';</span></span><br><span class="line"><span class="comment">// 연속 생성 시 키워드를 생략하지 않으면 에러 발생</span></span><br><span class="line"><span class="comment">let four = 4, let five = 5;</span></span><br><span class="line"><span class="comment">let dix = 6, var seven = 7;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="2-4-블록-스코프"><a href="#2-4-블록-스코프" class="headerlink" title="2.4 블록 스코프"></a>2.4 블록 스코프</h1><hr>
<p>let 변수를 선언하는 가장 큰 목적은 스코프 관리 입니다.<br>블록 스코프의 기준은 블록(중괄호)이며 블록 안과 밖의 변수 이름이 같더라도 스코프가 다르므로 변수가 선언되고 각 변수에 할당된 값이 대체되지 않고 유지됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-3] */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let 키워드로 선언하여 블록 단위 스코프를 가짐</span></span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sports) &#123;</span><br><span class="line">  <span class="keyword">let</span> sports = <span class="string">'농구'</span>;</span><br><span class="line">  <span class="comment">// 로컬 변수로 sports가 존재하므로 로컬변수의 값을 반환</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'블록: '</span>, sports);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 글로벌 변수의 값을 반환</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'글로벌: '</span>, sports);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="2-5-let과-this-키워드"><a href="#2-5-let과-this-키워드" class="headerlink" title="2.5 let과 this 키워드"></a>2.5 let과 this 키워드</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-this] */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> music = <span class="string">'음악'</span>;</span><br><span class="line"><span class="comment">// 여기서의 this는 상위 객체인 window 객체를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.music);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 키워드를 사용하면 window객체에 속하지 않음</span></span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.sports);</span><br></pre></td></tr></table></figure>
<p>위 예제에서 현재 스코프는 글로벌 오브젝트이고 this가 글로벌 오브젝트를 참조합니다.<br>(글로벌 오브젝트가 window오브젝트는 아니지만 window 오브젝트로 글로벌 변수에 접근할 수 있음)<br>즉 this가 window 오브젝트를 참조하는데 <u>let 키워드로 선언된 변수는 스코프가 글로벌 오브젝트더라도 window 오브젝트에 속하지 않는 차이가 있습니다.</u></p>
<p><br></p>
<h1 id="2-6-function"><a href="#2-6-function" class="headerlink" title="2.6 function"></a>2.6 function</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-function] */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>,</span><br><span class="line">    music = <span class="string">'재즈'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> music = <span class="string">'클래식'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 지역 변수가 존재하므로 지역 변수의 값을 참조</span></span><br><span class="line">  <span class="built_in">console</span>.lot(music);</span><br><span class="line">  <span class="comment">// 전역 변수만 존재하므로 전역 변수의 값을 참조</span></span><br><span class="line">  <span class="built_in">console</span>.lot(sports);</span><br><span class="line">&#125;</span><br><span class="line">get();</span><br></pre></td></tr></table></figure>
<p>함수의 안과 밖은 다른 스코프를 가지므로 변수 music의 값은 로컬 변수의 값을 참조 합니다.<br>이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-function-this] */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sports = <span class="string">'축구'</span>;</span><br><span class="line"><span class="keyword">let</span> music = <span class="string">'재즈'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sports = <span class="string">'농구'</span>;</span><br><span class="line">  <span class="keyword">let</span> music = <span class="string">'클래식'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1:'</span>, sports);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2:'</span>, <span class="keyword">this</span>.sports);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3:'</span>, <span class="keyword">this</span>.music);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.get();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  '농구'</span></span><br><span class="line"><span class="comment">  '축구'</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use strict가 선언되지 않았다면 정상적으로 출력</span></span><br><span class="line">get();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  '농구'</span></span><br><span class="line"><span class="comment">  error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<iframe scrolling="no" width="100%" height="280px" src="//jsfiddle.net/L1eu7sxf/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe>
<p>strict 모드에서 window.get()과 같이 get()앞의 오브젝트 위치에 window를 작성하는 경우 get() 함수 안에서 this가 window를 참조합니다. (여기서의 차이는 ES6가 아닌 ES5의 strict 모드의 제한)</p>
<p><br></p>
<h1 id="2-7-try-catch"><a href="#2-7-try-catch" class="headerlink" title="2.7 try-catch"></a>2.7 try-catch</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-try] */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sports = <span class="string">'농구'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(sports);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;  &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sports);</span><br></pre></td></tr></table></figure>
<p>try-catch문에서 try 블록 기준으로 블록 스코프를 가지며 catch 블록은 스코프를 갖지 않고 try 스코프에 속합니다.(?)</p>
<p>테스트<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> test = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 에러 발생</span></span><br><span class="line">  alert(none);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// catch 문 내에서 let 키워드를 사용하여 try 내부의 동일한 변수명으로 생성하였으나 문제 X</span></span><br><span class="line">  <span class="keyword">let</span> test = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<iframe scrolling="no" width="100%" height="280px" src="//jsfiddle.net/w8j4j3am/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe>
<p><br></p>
<h1 id="2-8-switch-case"><a href="#2-8-switch-case" class="headerlink" title="2.8 switch-case"></a>2.8 switch-case</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-switch] */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">'축구'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(count) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">let</span> sports = <span class="string">'농구'</span>;</span><br><span class="line">    <span class="comment">// 로컬 변수가 존재하므로 로컬 변수를 참조</span></span><br><span class="line">    <span class="built_in">console</span>.log(sports);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 글로벌 변수를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(sports)</span><br></pre></td></tr></table></figure>
<p>switch-case 문에서 switch 블록이 블록 스코프이며 case는 별도의 스코프를 갖지 않고 switch 스코프에 포함됩니다.(중괄호가 변수 스코프의 기준인 것을 확인할 수 있습니다.)</p>
<p><br></p>
<h1 id="2-9-호이스팅-hoisting"><a href="#2-9-호이스팅-hoisting" class="headerlink" title="2.9 호이스팅(hoisting)"></a>2.9 호이스팅(hoisting)</h1><hr>
<p>자바스크립트에서는 소스 코드를 위에서 아래로 순차적으로 실행 합니다.하지만 함수 선언문은 호출하는 코드를 호출될 함수의 위에 작성해도 호출이 되는데 이를 호이스팅이라고 합니다.<br>var 키워드로 생성된 변수도 선언 자체에 한해서 호이스팅이 일어나는 데 반면 let 키워드로 생성된 변수는 호이스팅이 일어나지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 let-hoisting] */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var 키워드는 선언에 한해서 호이스팅이 발생하므로 undefined를 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(sports);</span><br><span class="line"><span class="keyword">var</span> sports = <span class="string">'스포츠'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 키워드는 호이스팅이 발생하지 않으므로 에러</span></span><br><span class="line"><span class="built_in">console</span>.log(music);</span><br><span class="line"><span class="keyword">let</span> music = <span class="string">'음악'</span>;</span><br></pre></td></tr></table></figure>
<iframe scrolling="no" width="100%" height="280px" src="//jsfiddle.net/uoyb49e1/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe>
<p><br></p>
<h1 id="2-10-for"><a href="#2-10-for" class="headerlink" title="2.10 for"></a>2.10 for</h1><hr>
<p>for문에서의 let 키워드의 가장 큰 특징은 var와 달리 반복할 때마다 스코프를 가진다는 것 입니다.</p>
<p><strong> 비교 </strong><br><iframe scrolling="no" width="100%" height="280px" src="//jsfiddle.net/rm62ugmz/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe></p>
<p><strong>var 키워드를 사용하는 경우(event)</strong><br><iframe scrolling="no" width="100%" height="280px" src="//jsfiddle.net/fss3b84t/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe></p>
<p><strong>let 키워드를 사용하는 경우(event)</strong><br><iframe scrolling="no" width="100%" height="280px" src="//jsfiddle.net/k0wyroxc/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe></p>
<p><br></p>
<h1 id="2-10-const"><a href="#2-10-const" class="headerlink" title="2.10 const"></a>2.10 const</h1><hr>
<p>const 키워드로 할당된 값을 상수로 값을 변경할 수 없습니다.<br>상수의 개념이므로 이름을 중복하여 사용할 수 없으며 자바스크립트에서는 관계적으로 상수의 구분을 위해 상수는 영문 대문자로 표기하였지만 const키워드를 사용하면 키워드만으로도 구분할 수 있게 되었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 const-1] */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 키워드로 상수 SPORT를 선언</span></span><br><span class="line"><span class="keyword">const</span> SPORTS = <span class="string">'축구'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 상수에 값을 재할당 할 수 없으므로 catch문 실행</span></span><br><span class="line">  SPORTS = <span class="string">'농구'</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'const는 재할당 불가'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>단 위의 예제에서 try문 내 SPORTS에 let 키워드를 사용한다면 블록 스코프를 갖게 되므로 오류가 발생하지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [소스 const-2] */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 상수 obj 선언</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  language: <span class="string">'한글'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// obj는 상수이므로 에러 발생</span></span><br><span class="line">  obj = &#123;&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'const는 재할당 불가'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 키워드로 선언하더라도 객체 내 프로퍼티의 값은 변경할 수 있음</span></span><br><span class="line">obj.language = <span class="string">'영어'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.language);</span><br></pre></td></tr></table></figure>
<p>const 키워드로 선언된 obj에 object를 할당할 수는 없지만 프로퍼티의 값을 할당할 수는 있습니다. (프로퍼티를 추가하는 것도 가능)</p>
<p><br></p>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><hr>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><blockquote>
<ul>
<li>블록(중괄호) 스코프를 갖는다</li>
<li>호이스팅이 일어나지 않는다.</li>
<li>같은 스코프 안에서 let 키워드를 사용하여 동일한 이름의 변수를 선언할 수 없다.</li>
<li>글로벌 스코프에서 선언되어도 window객체에 포함되지 않는다.</li>
<li><del>try-catch문에서 try 블록 기준으로 블록 스코프를 가지며 catch 블록은 스코프를 갖지 않고 try 스코프에 속합니다.(?)</del></li>
</ul>
</blockquote>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote>
<ul>
<li>const 키워드로 상수를 선언할 수 있다.</li>
<li>호이스팅이 일어나지 않는다.</li>
<li>상수는 값을 변경하거나 동일한 이름의 변수나 상수를 할당할 수 없음</li>
<li>글로벌 스코프에서 선언되어도 window객체에 포함되지 않는다.</li>
<li>단 객체(배열)인 경우 프로퍼티를 추가, 변경, 삭제할 수 있습니다.</li>
</ul>
</blockquote>
</div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="./categories/study/">study</a><span class="category-list-count">37</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="./categories/study/ES6/">ES6</a><span class="category-list-count">9</span></li></ul></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="./2017/09/13/study-es6-3/"><i class="icon icon-arror-left"></i></a></li><li><a href="./2017/09/12/study-es5-7/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/windfanta" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.flickr.com/photos/69582358@N06/" title="flickr" target="_blank"><i class="icon icon-flickr"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 windfanta.github.io/blog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>