<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords"><title>(ES6) - 08 Object 오브젝트 - windfanta.github.io/blog</title><link rel="stylesheet" href="/blog/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/windfanta"><span>Github</span></a></li><li><a href="https://www.flickr.com/photos/69582358@N06/"><span>flickr</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">(ES6) - 08 Object 오브젝트</h1><ul class="meta"><li><i class="icon icon-author"></i>SUNGMIN SHIN</li><li><i class="icon icon-clock"></i>40 Minutes</li><li><i class="icon icon-calendar"></i>2017년 10월 13일</li></ul></div></div><div class="article-content" style="max-width:800px"><h1 id="ECMA-Script6"><a href="#ECMA-Script6" class="headerlink" title="[ ECMA Script6 ]"></a>[ ECMA Script6 ]</h1><p>(<a href="http://book.naver.com/bookdb/book_detail.nhn?bid=11556385" target="_blank" rel="noopener">http://book.naver.com/bookdb/book_detail.nhn?bid=11556385</a>)</p>
<p><br></p>
<h1 id="8-1-오퍼레이션"><a href="#8-1-오퍼레이션" class="headerlink" title="8.1 오퍼레이션"></a>8.1 오퍼레이션</h1><hr>
<p>ES6에서 Object 오브젝트에 프로퍼티를 작성하고 제어하는 방법이 추가되었으며 ES5와 다르게 변경된 것도 있습니다.</p>
<h2 id="Object에-같은-Key-사용"><a href="#Object에-같은-Key-사용" class="headerlink" title="Object에 같은 Key 사용"></a>Object에 같은 Key 사용</h2><p>Object의 key값이 같은 프로퍼티 두 개를 작성했을 때 ES버전별로 차이가 존재 합니다.<br>ES3: key값이 같더라도 추가<br>ES5: strict 모드에서 에러 발생<br>ES6: 모드 관계 없이 나중에 작성된 프로퍼티 값으로 대체</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sameKey = &#123;<span class="attr">one</span>: <span class="number">1</span>, <span class="attr">one</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sameKey.one);</span><br></pre></td></tr></table></figure>
<h2 id="변수-이름으로-값-설정"><a href="#변수-이름으로-값-설정" class="headerlink" title="변수 이름으로 값 설정"></a>변수 이름으로 값 설정</h2><p>변수 이름을 사용하여 Object 프로퍼티 값으로 설정가능</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> two = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> values = &#123;one,  two&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(values);</span><br></pre></td></tr></table></figure>
<h2 id="Object에-function-작성"><a href="#Object에-function-작성" class="headerlink" title="Object에 function 작성"></a>Object에 function 작성</h2><p>Object에 함수를 작성하는 방식은 ES5와 ES6가 차이를 가집니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">let</span> es5 = &#123;</span><br><span class="line">  getTotal: <span class="function"><span class="keyword">function</span>(<span class="params">param</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param + <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">  getTotal(param) &#123;</span><br><span class="line">    <span class="keyword">return</span> param + <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(es5.getTotal(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">console</span>.log(es6.getTotal(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="8-2-디스크립터-Descriptor"><a href="#8-2-디스크립터-Descriptor" class="headerlink" title="8.2 디스크립터(Descriptor)"></a>8.2 디스크립터(Descriptor)</h1><hr>
<p>디스크립터는 ES5에서 제시되었으며 ES6에서 이를 바탕으로 여러 기능이 추가 되었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'book'</span> ,&#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>참고: <a href="https://msdn.microsoft.com/ko-kr/library/dd548687(v=vs.94).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/ko-kr/library/dd548687(v=vs.94).aspx</a></p>
</blockquote>
<h2 id="프로퍼티-디스크립터"><a href="#프로퍼티-디스크립터" class="headerlink" title="프로퍼티 디스크립터"></a>프로퍼티 디스크립터</h2><p>상세 내용은 표8-1(P95) 참고<br>데이터 타입의 value, writable 그리고 액세스 타입의 get, set속성은 함께 작성할 수 없으며 프로퍼티 디스크립터에서는 타입을 별도로 작성하지 않고 속성으로 데이터 타입과 액세스 타입을 구분합니다 (즉 타입이 기본 값을 가지고 있으므로 별도의 선언이 없다면 기본 값으로 사용)</p>
<p><br></p>
<h1 id="8-3-get-set-속성"><a href="#8-3-get-set-속성" class="headerlink" title="8.3 get, set 속성"></a>8.3 get, set 속성</h1><hr>
<p>get 속성은 getter의 기능을 set 속성을 setter의 기능을 제공합니다.</p>
<h2 id="get-속성"><a href="#get-속성" class="headerlink" title="get 속성"></a>get 속성</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'book'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'책'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.book);</span><br></pre></td></tr></table></figure>
<p>1&gt; obj에서 book프로퍼티 작성 여부를 체크<br>2&gt; get속성 여부를 체크<br>3&gt; get 속성 값인 함수를 실행<br>의 순서로 실행되며 getter는 함수를 호출하는 형태 obj.book()이 아닌 obj.book으로 함수 이름만 작성합니다.</p>
<h2 id="set-속성"><a href="#set-속성" class="headerlink" title="set 속성"></a>set 속성</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'set'</span>, &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.result = param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.set = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.result);</span><br></pre></td></tr></table></figure>
<p>1&gt; obj에서 set프로퍼티 작성 여부를 체크<br>2&gt; set 속성 여부를 체크<br>3&gt; set 속성 값인 함수를 실행<br>의 순서로 실행되며 setter는 함수를 호출하는 형태 obj.set(100)이 아닌 obj.set = 100의 형태로 작성합니다.<br>여기서 getter로 사용되는 obj.result는 get 속성을 작성하지 않았지만 디폴트 getter가 호출되어 obj의 result프로퍼티의 값을 반환합니다.</p>
<p><br></p>
<h1 id="8-4-getter-ES6"><a href="#8-4-getter-ES6" class="headerlink" title="8.4 getter(ES6)"></a>8.4 getter(ES6)</h1><hr>
<p>ES6에서의 getter는 함수(메서드) 이름 앞에 명시적으로 get을 작성하며 function키워드를 생략하고 아래와 같이 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  get getValue()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getValue);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="8-5-setter-ES6"><a href="#8-5-setter-ES6" class="headerlink" title="8.5 setter(ES6)"></a>8.5 setter(ES6)</h1><hr>
<p>ES6에서의 setter는 함수(메서드) 이름 앞에 명시적으로 set을 작성하며 function키워드를 생략하고 아래와 같이 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  set setValue(value)&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.setValue = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.value);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="8-6-is-값과-값-타입-비교"><a href="#8-6-is-값과-값-타입-비교" class="headerlink" title="8.6 is(): 값과 값 타입 비교"></a>8.6 is(): 값과 값 타입 비교</h1><hr>
<p>두 개의 파라미터 값과 값 타입을 비교하여 같으면 true를 아니면 false를 반환합니다.<br>하지만 값과 값 타입을 비교하는 것이지 오브젝트를 비교하는 것은 아니며 그렇기 때문에 Array와 Array를 비교하거나 Object와 Object를 비교하는 경우 false가 반환 됩니다.</p>
<blockquote>
<p>== (값만 비교)<br>=== (값과 값의 타입을 모두 비교)<br>Object.is() (값과 값의 타입을 모두 비교 0의 음수, 양수여부 그리고 NaN을 비교할 수 있음)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1:'</span>, <span class="built_in">Object</span>.is(<span class="number">1</span>, <span class="string">'1'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2:'</span>, <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>), <span class="literal">NaN</span> === <span class="literal">NaN</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3:'</span>, <span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>), <span class="number">0</span> === <span class="number">-0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4:'</span>, <span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">0</span>), <span class="number">-0</span> === <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5:'</span>, <span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>), <span class="number">-0</span> === <span class="number">-0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'6:'</span>, <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>), <span class="literal">NaN</span> === <span class="number">0</span>/<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'7:'</span>, <span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>), <span class="literal">null</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'8:'</span>, <span class="built_in">Object</span>.is(<span class="literal">undefined</span>, <span class="literal">null</span>), <span class="literal">undefined</span> === <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="8-7-assing-오브젝트-프로퍼티-복사"><a href="#8-7-assing-오브젝트-프로퍼티-복사" class="headerlink" title="8.7 assing(): 오브젝트 프로퍼티 복사"></a>8.7 assing(): 오브젝트 프로퍼티 복사</h1><hr>
<p>두 번째 파라미터의 오브젝트 프로퍼티를 첫 번 째 파라미터의 오브젝트 끝에 복사하고 첫 번째 파라미터를 반환 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(<span class="literal">null</span>, &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'null 지정 불가'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 번째 프로퍼티에 Number를 넣는 경우</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(<span class="number">123</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(<span class="number">123</span>) == <span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="built_in">Object</span>.assign(<span class="number">123</span>), <span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 번째, 두 번째 프로퍼티에 Number를 넣는 경우</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(<span class="number">456</span>, <span class="number">70</span>));</span><br></pre></td></tr></table></figure>
<p>첫 번째 파라미터에 열거 가능한 오브젝트가 아닌 Boolean, Number, String, Symbol을 지정하는 경우 값 타입의 오브젝트(primitiveValue)를 생성하며 지정하지 않거나 undefined와 null을 지정하면 에러가 발생 합니다.<br>(즉 Boolean, Number, String, Symbol가 첫 번째 파라미터에 지정되는 경우 파라미터의 값을 primitiveValue에 지정하고 해당 오브젝트를 생성되며 이렇게 생성된 오브젝트의 primitiveValue는 valueOf() 그리고 Symbol.toPrimitive로 확인할 수 있습니다.)<br>두 번째 이후 파라미터에는 열거 가능한 오브젝트가 아니라면 복사되지 않습니다.<br>프로퍼티에 복사는 own 프로퍼티로 한정되어 prototype과 프로퍼티 디스크립터는 복사되지 않습니다.</p>
<blockquote>
<p>참고: primitiveValue (<a href="http://webclub.tistory.com/240" target="_blank" rel="noopener">http://webclub.tistory.com/240</a>)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(<span class="string">'ABC'</span>, &#123;<span class="attr">one</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// String 오브젝트는 이터러블 오브젝트이므로 나열되어 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// primitiveValue를 연산하는 경우</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2 + <span class="string">'DEF'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol 타입으로 생성되며 primitiveValue는 'ABC'가 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(<span class="built_in">Symbol</span>(<span class="string">'ABC'</span>), &#123;<span class="attr">one</span>: <span class="number">1</span>&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 양쪽 파라미터 모두에 문자열은 사용할 수 없음</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(<span class="string">'ABC'</span>, <span class="string">'ONE'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'파라미터 모두 문자열 사용 불가'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneObj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(oneObj, <span class="string">'ABC'</span>, <span class="literal">undefined</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// Object.assign('ABC', undefined, null)과 동일</span></span><br><span class="line"><span class="built_in">console</span>.log(oneObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoObj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(twoObj, &#123;<span class="attr">key1</span>: <span class="literal">undefined</span>, <span class="attr">key2</span>: <span class="literal">null</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(twoObj);</span><br></pre></td></tr></table></figure>
<p>oneObj와 같이 첫 번째 파라미터에 오브젝트를 지정하고 두 번째 문자열 파라미터를 작성하면 ‘ABC’가 primitiveValue로 복사되지만 그 다음 파라미터들은 복사되지 않습니다.<br>twoObj처럼 파라미터가 아닌 Object의 프로퍼티 값으로 undefined나 null인 경우에는 에러없이 복사됩니다.  </p>
<p><br></p>
<h1 id="8-8-assign-의-필요성"><a href="#8-8-assign-의-필요성" class="headerlink" title="8.8 assign()의 필요성"></a>8.8 assign()의 필요성</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sports = &#123;</span><br><span class="line">  event: <span class="string">'축구'</span>,</span><br><span class="line">  player: <span class="number">11</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dup1 = sports;</span><br><span class="line"><span class="keyword">let</span> dup2 = <span class="built_in">Object</span>.assign(&#123;&#125;, sports);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dup1.event, dup2.event);</span><br><span class="line">sports.event = <span class="string">'농구'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dup1.event, dup2.event);</span><br></pre></td></tr></table></figure>
<p>위의 예제와 같이 빈 Object를 첫 번째로 인자로 사용하여 오브젝트의 프로퍼티를 복사하면 프로퍼티의 값이 연동되지 않습니다.</p>
<p><br></p>
<h1 id="8-9-assign-고려사항"><a href="#8-9-assign-고려사항" class="headerlink" title="8.9 assign() 고려사항"></a>8.9 assign() 고려사항</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneObj = &#123;<span class="attr">one</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> twoObj = &#123;<span class="attr">two</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> mergeObj = <span class="built_in">Object</span>.assign(oneObj, twoObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  mergeObj</span></span><br><span class="line"><span class="comment">  1&gt; mergeObj에서 Object.assign이 실행</span></span><br><span class="line"><span class="comment">  2&gt; oneObj에 twoObj의 프로퍼티를 복사</span></span><br><span class="line"><span class="comment">  3&gt; 복사한 값을 oneObj에 할당</span></span><br><span class="line"><span class="comment">  4&gt; 복사한 값을 반환</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  즉 반환 값이 첫 번째 파라미터에 복사한 값을 할당된 후 반환되므로 연동을 피하려면 빈 Object를 첫번 째 값으로 넣어야 합니다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(oneObj, mergeObj));</span><br><span class="line"></span><br><span class="line">mergeObj.one = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(oneObj, mergeObj));</span><br></pre></td></tr></table></figure>
<p>위 예제와 같이 첫 번째 파라미터에 oneObj에 복사한 값을 할당 후 반환하므로 값이 연동되게 됩니다.<br>그리고 Object.assign({}, {one:1}, {two:2}, {two:3}) 과 같이 다수의 Object를 작성할 수 있으며 이때 왼쪽에서 오른쪽을 순서로 프로퍼티를 복사하게 되어 중복되는 키값은 대체되게 됩니다.</p>
<p><br></p>
<h1 id="8-10-assign-getter"><a href="#8-10-assign-getter" class="headerlink" title="8.10 assign() getter"></a>8.10 assign() getter</h1><hr>
<p>프로퍼티를 복사할 때 프로퍼티가 getter라면 함수가 아닌 return 값을 복사하게 됩니다(return 값이 없는 경우 undefined를 반환)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = &#123;</span><br><span class="line">  current: <span class="number">1</span>,</span><br><span class="line">  get getCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++<span class="keyword">this</span>.current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mergeObj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(mergeObj, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기서 count의 값이 1인 이유는 복사하는 시점의 값을 가져오기 때문</span></span><br><span class="line"><span class="built_in">console</span>.log(mergeObj);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="8-11-setPrototypeOf"><a href="#8-11-setPrototypeOf" class="headerlink" title="8.11 setPrototypeOf"></a>8.11 setPrototypeOf</h1><hr>
<blockquote>
<p>Object.setPrototypeOf( 오브젝트나 인스턴스, prototype이나 오브젝트나, null)</p>
</blockquote>
<p>setPrototypeOf는 null이나 또다른 객체에 특정 객체 프로토타입을 설정할 수 있는 메서드로 첫 번째 파라미터에 오브젝트나 인스턴스를 지정하며 만약 결과가 false(즉 오브젝트에 프로퍼티를 추가, 확장할 수 없다면)라면 에러가 발생됩니다.<br>Boolean, Number, String, Symbol을 지정하는 경우 오브젝트를 생성하여 반환하지만 이 때 두 번째 파라미터를 생성한 오브젝트에 반영하지 않습니다.</p>
<p>두 번째 파라미터에는 오브젝트나 null을 지정하며 prototype이 아닌 function이나 인스턴스를 지정해도 에러가 발생하진 않지만 목적에 적합하지 않습니다.</p>
<blockquote>
<p>참고: setPrototypeOf (<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf</a>)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Sports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Sports.prototype.getCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sports의 prototype을 protoObj에 복사되어 protoObj.__proto__.getCount가 존재하게 됨</span></span><br><span class="line"><span class="keyword">let</span> protoObj1 = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, Sports.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(protoObj1.getCount());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 파라미터가 prototype이 아닌 변수 자체를 지정하는 경우 직접 호출할 수 없음</span></span><br><span class="line"><span class="keyword">let</span> protoObj2 = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, Sports);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(protoObj2.getCount());</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'에러'</span>, protoObj2.prototype.getCount.call(Sports));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="8-12-proto"><a href="#8-12-proto" class="headerlink" title="8.12 proto"></a>8.12 <strong>proto</strong></h1><hr>
<p><strong>proto</strong>에 new 연산자로 생성한 인스턴스 또는 다른 오브젝트의 prototype에 연결된 프로퍼티가 첨부 됩니다.</p>
<p>인스턴스를 생성하면 오브젝트의 prototype에 연결된 프로퍼티가 인스턴스의 <strong>proto</strong>에 첨부됩니다. 이 환경이 만들어지면 prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있게 됩니다. (여기서 <strong>proto</strong>에 첨부된다는 의미는 복사가 아닌 (메모리 주소 값의)참조)</p>
<h2 id="prototype과-proto의-차이"><a href="#prototype과-proto의-차이" class="headerlink" title="prototype과 proto의 차이"></a>prototype과 <strong>proto</strong>의 차이</h2><p><strong>proto</strong>에 존재하는 메서드는 object.name()의 형태로 직접 호출할 수 있지만 prototype에 연결된 메서드는 object.prototype.name.call()의 형태로 호출해야 합니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Sports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.member = <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Sports.prototype.getMember = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sportsObj = <span class="keyword">new</span> Sports();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1&gt; Sports의 member가 sportsObj의 인스턴스 프로퍼티로 첨부</span></span><br><span class="line"><span class="comment">  2&gt; new 연산자로 생성자 함수를 호출하면 엔진이 __proto__를 생성하고 prototype에 연결된 프로퍼티를 첨부</span></span><br><span class="line"><span class="comment">  3&gt; 이렇게 연결된 prototype은 메모리의 주소를 참조하므로 시스템적으로 동일</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sportsObj.__proto__ === Sports.prototype);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Sports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Sports.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sportsObj = <span class="keyword">new</span> Sports();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sportsObj의 __proto__에 메서드를 추가했지만 실제로는 Sports.prototype에 추가 됨</span></span><br><span class="line"><span class="comment">// 이는 Sports로 생성한 다른 인스턴스에서 추가한 set() 메서드를 공유하기 때문(콘솔 확인) </span></span><br><span class="line">sportsObj.__proto__[<span class="string">'set'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">sportsObj.set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> Sports();</span><br><span class="line"><span class="built_in">console</span>.log(result.set);</span><br><span class="line"><span class="built_in">console</span>.log(sportsObj);</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><hr>
<h2 id="오퍼레이션"><a href="#오퍼레이션" class="headerlink" title="오퍼레이션"></a>오퍼레이션</h2><blockquote>
<ul>
<li>ES6에서는 같은 키 값을 중복하여 할당하더라도 에러가 발생하지 않으며 나중에 작성된 프로퍼티 값으로 대체</li>
<li>변수의 이름을 사용하여 Object의 프로퍼티 값을 설정할 수 있다</li>
<li>Object에 function을 작성 시 function 키워드를 작성하지 않는 형태로 변경</li>
</ul>
</blockquote>
<h2 id="get-set-속성"><a href="#get-set-속성" class="headerlink" title="get, set 속성"></a>get, set 속성</h2><blockquote>
<ul>
<li>get 속성은 getter의 기능을 set속성은 setter의 기능을 제공</li>
<li>함수의 앞에 get, set 키워드를 작성하여 사용(ES6도 동일, 단 function 키워드는 작성하지 않음) </li>
</ul>
</blockquote>
<h2 id="is"><a href="#is" class="headerlink" title="is()"></a>is()</h2><blockquote>
<ul>
<li>Object.is()는 값과 값의 타입을 비교(오브젝트를 비교하는 것이 아님)</li>
<li>‘===’ 기본 적으로 동일하지만 0의 음수, 양수 그리고 NaN 비교할 수 있다.</li>
</ul>
</blockquote>
<h2 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h2><blockquote>
<ul>
<li>Object.assign()은 오브젝트 프로퍼티를 복사하는 메서드 </li>
<li>이 때 prototype과 프로퍼티 디스크립터는 복사되지 않음. (own 프로퍼티만 복사) </li>
<li>첫 번째 파라미터에 Boolean, Number, String, Symbol을 지정하면 값 타입의 오브젝트를 생성하고 primitiveValue에 값을 할당</li>
<li>assign 메서드를 활용하면 프로퍼티 값의 연동을 제어할 수 있음</li>
<li>getter 프로퍼티를 복사하는 경우 반환된 값을 복사(return문이 없다면 undefined를 반환)</li>
</ul>
</blockquote>
<h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h2><blockquote>
<ul>
<li>Object.setPrototypeOf는 null이나 또다른 객체에 특정 객체 프로토타입을 설정할 수 있는 메서드</li>
<li>첫 번째 파라미터에 오브젝트나 인스턴스를 지정하며 만약 결과가 false(즉 오브젝트에 프로퍼티를 추가, 확장할 수 없다면)라면 에러가 발생</li>
<li>첫 번째 파라미터에 Boolean, Number, String, Symbol을 지정하는 경우 오브젝트를 생성하여 반환하지만 이 때 두 번째 파라미터를 생성한 오브젝트에 반영하지 않음</li>
<li>두 번째 파라미터에는 오브젝트나 null을 지정, prototype이 아닌 function이나 인스턴스를 지정해도 에러가 발생하진 않지만 목적에 적합하지 않음</li>
</ul>
</blockquote>
<h2 id="8-12-proto-1"><a href="#8-12-proto-1" class="headerlink" title="8.12 proto"></a>8.12 <strong>proto</strong></h2><blockquote>
<ul>
<li><strong>proto</strong>에 new 연산자로 생성한 인스턴스 또는 다른 오브젝트의 prototype에 연결된 프로퍼티가 첨부 됨</li>
<li>인스턴스를 생성하면 오브젝트의 prototype에 연결된 프로퍼티가 인스턴스의 <strong>proto</strong>에 첨부(참조할 수 있게)되며 prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있게 됨</li>
<li><strong>proto</strong>에 첨부된 prototype은 메모리 주소 값을 참조하는 형태</li>
<li><strong>proto</strong>에 존재하는 메서드는 object.name()의 형태로 직접 호출할 수 있지만 prototype에 연결된 메서드는 object.prototype.name.call()의 형태로 호출해야 함</li>
<li>인스턴스에 <strong>proto</strong>에 값을 추가하더라도 생성자 함수에 prototype이 추가 됨</li>
</ul>
</blockquote>
</div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/study/">study</a><span class="category-list-count">41</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/study/ES6/">ES6</a><span class="category-list-count">9</span></li></ul></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/blog/2017/10/17/study-vue-3/"><i class="icon icon-arror-left"></i></a></li><li><a href="/blog/2017/10/11/study-es6-7/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/windfanta" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.flickr.com/photos/69582358@N06/" title="flickr" target="_blank"><i class="icon icon-flickr"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 windfanta.github.io/blog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>